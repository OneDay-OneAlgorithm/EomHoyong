## 해설

666이 포함된 수를 몇 개 나열해 보면 대략 패턴이 보인다.

0666  
1666  
2666  
3666  
4666  
5666  
6660  
6661  
6662  
6663  
6664  
6665  
6666  
6667  
6668  
6669  
7666  
...  
15666  
16660  
...  
16669  
...  
65666  
66600  
...  
66699  
67666  


666에 1000씩 더해가다보면 십의 자리 이상에서  
666이라는 수열이 나타나는 경우가 생긴다.  
이때 666 이후를 0으로 만들고 0, 1, 2, ...하고 세면 된다.  
예를 들어 166666의 경우 166600을 만든 후 166600, 166601, ...하고 세면 된다.  
설명의 편의를 위해 166666을 166600으로 만드는 행위를 '깎는다'고 표현하겠다.  

166666은 백의 자리에서 666이 생겼으므로 166666을 깎아 166600을 만든다.  
내 경우에는 어느 자리에서 666이 생기는지 확인할 check 함수를 만들었다.  
check 함수는 1의 자리에서 666이 생겼다면 0,  
10의 자리에서 666이 생겼다면 1...과 같이 연산해 값을 반환한다.  
pow 함수로 10^(check(num))을 변수 c에 담아준다.  
(int)(166666/c)*c로 166666을 깎는다.  
※ cmath의 pow 함수를 사용하면 double 값이 반환되는데,  
이를 int로 강제 형변환 할 경우 10^2가 99가 되는 현상이 있어  
간단하게 pow 함수를 구현해보았다.

166600(num)부터 c개 만큼 666이 포함된 수를 만들 수 있으므로,  
(지금까지의 수의 개수 n) + c < N 일 경우 n += c 해주고,  
(지금까지의 수의 개수 n) + c >= N 일 경우 (깎은 num) + (N-n-1)을 출력하고 종료한다.  

이러한 과정을 통해 답을 구할 수 있다.